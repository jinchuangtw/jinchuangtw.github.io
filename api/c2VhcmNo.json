[{"title":"使用 CMake 建置 OpenCV 專案","date":"2022-09-02T13:52:41.000Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T15:47:38.424Z","content":"簡單記錄一下 CMake 的基本使用方式與專案結構。\n\nCMake 是什麼\nCMake 是一個可以管理並建置程式專案的工具，直觀一點地說，它可以幫你引入程式需要的第三方函式庫，並連同專案內的 header files、source files 一起編譯出最終的執行檔。同時，CMake 也是 OpenCV 官方文件中優先建議的編譯工具。用來設置 CMake 各項參數的檔案，就叫做 CMakeLists.txt，使用者必須根據自己的需求，把各個檔案的路徑寫在這裡面，告訴 CMake 程式檔案之間的關聯。\n專案結構\n參考視覺SLAM十四講 Chapter 13 的內容，可以看到專案根目錄首先會有一個最主要的 CMakeLists.txt，而在 src、app、test 這三個資料夾底下也各有一個。另外，一些第三方函式庫的詳細引用方法，則定義在 cmake_modules 的 .cmake 檔案中。完整的專案結構如下所示：\n123456789101112131415161718project_root          |-- app          |    |-- CMakeLists.txt          |    |-- run_kitti_stereo.cpp          |-- config               |-- cmake_modules          |             |-- FindCSparse.cmake          |             |-- FindG2O.cmake          |             |-- FindGlog.cmake          |-- include/myslam          |             |-- (... user header files ...)          |-- src          |    |-- CMakeLists.txt          |    |-- (... user source files ...)          |-- test          |    |-- CMakeLists.txt          |    |-- test_triangulation.cpp          |-- CMakeLists.txt\n由這個結構可以看出，使用者應將自己寫的 header files 放在 include 目錄中，並使用自定義的函式庫名稱作為子資料夾。而所有的 source files 則可以放在 src 目錄下。\n再來，test 和 app 目錄下則用來存放測試用的程式，以及專案的主程式。\nCMake 設置常用語法\nCMake 專案設置\n首先在根目錄中、最主要的那個 CMakeLists.txt 裡面，使用者必須先設定好版本與專案資訊。如果有將第三方函式庫的詳細引入方式寫成 .cmake 檔的話，可以註明那些檔案的位置。\n12345678cmake_minimum_required(VERSION 2.8)project(myslam)set(CMAKE_BUILD_TYPE Release) # Release / Debug，debug的話，編譯出的執行檔會跑得比較慢list(APPEND CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake_modules) # .cmake 的路徑set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin) # 執行檔輸出路徑set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib) # 使用者函式庫編譯路徑\n引入 OpenCV 等等第三方函式庫\n再來，使用者可以透過 find_package 讓 CMake 自己尋找第三方套件的檔案路徑，並且用 include_directories 告訴 CMake 要把這些東西加到專案的 include 路徑裡面，這樣我們的程式就可以使用第三方的 functions。\n1234# OpenCVfind_package(OpenCV 3.1 REQUIRED) # 也可以像這樣指定套件版本include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)set(THIRD_PARTY_LIBS $&#123;OpenCV_LIBS&#125;) # 把多個第三方函示庫的路徑整理在一起，統稱 THIRD_PARTY_LIBS\n引入使用者自己的函式庫\n剛剛已經把專案底下使用者自己寫的 libraries 都放在 include 目錄下了，所以這邊只需要直接用 include_directories 把他們加進去就好。\n1include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)\n定義來源檔案路徑\n在上一小節有提到來源檔案根據性質（是 libraries 還是主程式？）可以放在對應的資料夾中。這邊就運用 add_subdirectory 告訴 CMake 這些來源檔案的路徑。\n123add_subdirectory(src)add_subdirectory(test)add_subdirectory(app)\n編譯函式庫\n使用者自己函式庫的來源檔案可以透過 add_library 進行連結。如果這個函式庫也需要用到第三方函式庫的東西，可以再用 target_link_libraries 把它們連起來。\n123456789101112131415add_library(myslam SHARED # 使用者函式庫名稱與類型        frame.cpp        mappoint.cpp        map.cpp        camera.cpp        config.cpp        feature.cpp        frontend.cpp        backend.cpp        viewer.cpp        visual_odometry.cpp        dataset.cpp)target_link_libraries(myslam        $&#123;THIRD_PARTY_LIBS&#125;)\n編譯主程式\nadd_executable 可以告訴 CMake 要根據誰產生執行檔，以及執行檔要叫什麼名字。主程式裡面用到的所有函式庫則可以一次用 target_link_libraries 進行連結。\n12add_executable(run_kitti_stereo run_kitti_stereo.cpp) # 執行檔名稱 與 主程式檔名target_link_libraries(run_kitti_stereo myslam $&#123;THIRD_PARTY_LIBS&#125;) # 這個執行檔會用到的函式庫們\n結語\n假設專案非常簡單，使用者其實只需要一個 CMakeLists.txt 就可以搞定所有設置，但是，實務上的大型專案往往包括許多使用者自己寫的函式庫與多個程式，如同這次的範例，我們可以利用模組化的方式來進行 CMake 連結，也更好進行檔案管理。至於這次沒有寫到的測試檔案設置方式，就等日後有需要用到時再進行研究補充。\nThumbnail photo from Unsplash\n","thumbnail":"2022/09/02/22-09-02-cmake-tutorial/thumbnail.png","plink":"https://jinchuangtw.github.io/2022/09/02/22-09-02-cmake-tutorial/"},{"title":"Leetcode - 9. Palindrome Number","date":"2022-08-19T10:50:34.000Z","date_formatted":{"ll":"Aug 19, 2022","L":"08/19/2022","MM-DD":"08-19"},"updated":"2022-08-19T12:37:12.662Z","content":"009. Palindrome Number\nProblem\nhttps://leetcode.com/problems/palindrome-number/\nIntuition\nIn this problem, we have to reverse the input integer to see whether the reversed number is the same as the original input. So the first solution that came to my mind was to reverse it and store the result in a new variable. By this way, we could directly return reversed number == input number.\nSolution Planning\n\nSince the input may be negative, we could return false once x &lt; 0.\nSince the input constrain is \n-2^{31} \\leq x \\leq 2^{31}-1\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n \n\n\n \n \n \n\n \n\n \n \n\n\n \n \n\n, if we reverse an integer with 10 digits, it may exceed the limit of int. This could be solved by using long long.\n\nCode\n12345678910111213bool isPalindrome(int x) &#123;    if (x &lt; 0) &#123;        return false;    &#125; else &#123;        long long reversedNum = 0;        int lost = x;        while (lost != 0) &#123;            reversedNum = reversedNum * 10 + lost % 10;            lost = lost / 10;        &#125;        return reversedNum == x;    &#125;&#125;\n","plink":"https://jinchuangtw.github.io/2022/08/19/22-08-19-leetcode-009/"},{"title":"Neovim 高效開發環境：配置心得與分享","date":"2022-08-05T06:59:34.000Z","date_formatted":{"ll":"Aug 5, 2022","L":"08/05/2022","MM-DD":"08-05"},"updated":"2022-09-03T11:48:17.143Z","content":"10dd 一次刪除 10 行、yG 複製至檔案末端 … 是時候挑戰這個神秘古老的編輯器了。\n\n\n點擊畫面右下角選單可以開啟目錄！\n\n前言：為何不使用現成的 IDE\n在這個人人學程式的時代，集成式開發環境（Integrated Development Environment, IDE）往往是入門者寫程式的首選，其直覺化的圖形介面、便捷的程式庫引入方式，可以讓使用者免於繁複的設定，只需專注學習程式的概念以及語法 —— 例如我在大學修 C、C++ 時常用的 Visual Studio，抑或是 Python 專用的 PyCharm 等。\n然而，此類 IDE 往往有著以下顯著的缺點：\n\n軟體檔案肥大，佔據電腦大量儲存空間\n\n相對輕量化的開源 IDE 如：Dev-C++，是我八年前（欸？）最喜歡的編輯器，可惜作者已不再更新、維護\n\n\n啟動速度慢，而且當你裝了越多插件，就又更慢\n介面充滿花花綠綠的按鈕與各種複雜的 panels，壓縮程式碼的編輯空間，換言之就是很醜（主觀發言）\n\n另外，不同於龐大精密的 IDE，近年備受開發者青睞的 Visual Studio Code 與 Atom 這類現代化文字編輯器，則可以透過自行安裝的插件來滿足各式使用需求，不論是不同程式語言的開發，或是 tex、markdown 等等文件編輯，都可以在插件市集中找到支援。\n不過，在文字編輯器的領域，依然存在著一個神秘古老的選擇，從未離開人們的視野… 對，那就是 Vim。兼具超輕量化、跨平台通用性（Linux, macOS, WSL）、100% 可自定義的功能以及讓你可以就此丟掉滑鼠的快捷鍵組合，使得 Vim 成為一套讓使用者「越用越順手」的開發環境。若再搭配 tmux 使用，更可以使整個終端機工作的效率達到最大值。\n\n    \n\n\n推我入坑的最大契機：Neovim + tmux = 超級順暢的 workflow！(How to build a smoothly animated ToDo app with React Native, Expo, Reanimated, NativeBase, and Moti – devaslife@YouTube)\n\n本文使用的 Neovim 則是源自 Vim 的分支版本。不同於 Vim 只由一位主要開發者進行所有 pull requests 的管理，Neovim 的開發社群相對龐大，因此在新功能的增添上更為活絡。我在這篇文章中的配置方式參考了這篇教學，作者對 Neovim 的配置概念與步驟做了非常詳細的說明。\n一、Neovim 基礎安裝與環境配置\nNeovim 的安裝非常簡單，可以直接透過 apt 或 brew 之類的套件管理器完成。例如：\nmacOS\n1brew install neovim --HEAD\nLinux / WSL 的話是\n12sudo apt updatesudo apt install neovim\n另外，我們還會需要一個可以正常顯示 nerd 字符的環境。不同於各平台終端機內建的字型，nerd-font 的好處是支援各種圖形符號，可以讓我們的 UI 更為美觀直覺。我在 WSL 用的終端機是 Tabby，macOS 則是 iTerm2，這些終端機都可以支援 nerd-font。\nNerd-font 有非常多種字型可以選擇，我自己是用這些：\n\nMesloLGS NF Regular.ttf\nMesloLGS NF Bold.ttf\nMesloLGS NF Italic.ttf\nMesloLGS NF BoldItalic.ttf\n\n二、配置文件架構\nNeovim 跟 Vim 比較不一樣，使用者必須在自己的家目錄底下建立 .config/nvim 路徑，並把所有相關配置文件都放到裡面。每次打開 Neovim，它都會自動執行 init.lua 這個入口文件，把裡面所有設定都跑一遍。\n這些檔案的架構大概會是這個樣子：\n12345678910111213~/.config/nvim    |    |--- init.lua # 入口文件    |--- lua    |     |--- basic.lua # 顯示與 Neovim 基本設定    |     |--- keybingings.lua # 快捷鍵自定義    |     |--- colorscheme.lua # 外觀主題    |     |--- plugins.lua # 管理所有插件的安裝    |     |--- plugin-config    |     |          |--- # ... 插件各自的配置    |     |     |     |--- lsp    |     |     |--- # ... lsp server 各自的配置\n將各個插件的配置以模組概念分開來的好處是，當你某一天想要關閉某個插件時，只需要把入口文件中引入那個插件的一行 code 註解掉就可以了。\n三、插件 &amp; 我的配置分享\n在插件管理上，我用的是 packer.nvim，先把這個管理器安裝好之後，只要把所有想安裝的插件列在 plugins.lua，然後執行 :PackerSync 就可以了。另外，如果是要把 Neovim 拿來寫 code，不外乎還會需要以下這些功能：\n\n語法高亮\n自動補全\nCode 自動排版\n模糊搜索\n檔案管理介面\n\n詳細相關的插件，可以參考我的 Neovim 配置文件，由於我主要是打算拿來寫 c、cpp、python、tex 還有 markdown，所以如果還需要寫其他語言，就必須安裝相對應的 LSP server，才能實現自動補全功能。各語言可用的 server 可以參考 nvim-lspconfig 的說明文件。Code 自動排版的部分則可以參考 null-ls 的 built-in sources，注意在配置好之後，也要安裝各語言自動排版的套件，null-ls 才可以去 call 它。\n例如我看到 null-ls 可以用 clang-format 這個 command 去排版 c 跟 cpp，\n\n那我就知道我必須另外安裝 clang-format，以此類推。\n\n透過這次下定決心把 Neovim 配起來，終於可以在全 terminal 環境下作業了！完全不用伸手碰滑鼠就是爽(=´∀｀)人(´∀｀=)\n\n用 Neovim 搭配 tmux 的多開方法，左邊編輯，右邊開 server，即時查看渲染結果。\nThumbnail photo from Unsplash\n","thumbnail":"2022/08/05/22-08-05-neovim-tutorial/coding.jpg","plink":"https://jinchuangtw.github.io/2022/08/05/22-08-05-neovim-tutorial/"},{"title":"About","date":"2022-08-13T07:48:50.000Z","date_formatted":{"ll":"Aug 13, 2022","L":"08/13/2022","MM-DD":"08-13"},"updated":"2022-09-02T13:13:50.412Z","content":"\n“My formula for greatness in a human being is amor fati: that one wants nothing to be different, not forward, not backward, not in all eternity. Not merely bear what is necessary, still less conceal it—all idealism is mendacity in the face of what is necessary—but love it.” – Friedrich Nietzsche\n\nResearch\n\nStereo V-SLAM\n\nIEEE Publications\n\nEvaluation of ORB-SLAM based Stereo Vision for the Aircraft Landing Status Detection on 2022 IECON\n\n\n\n\nEmbedded Operating System\n\nBuilt An Embedded System for Field Workers Safety Detection based on FreeRTOS\n\n\n\nProgramming\n\nC++\nC\nPython\nMatlab\n\nBio\n\nNow\nStudying master’s degree at NCKU dept. of Aeronautics and Astronautics （國立成功大學航空太空工程研究所）\n2021\nGraduated from NCKU dept. of Aeronautics and Astronautics（國立成功大學航空太空工程學系）\n2017\nGraduated from National Tainan Girls’ Senior High School（國立臺南女子高級中學）\n1999\nBorn in Tainan, Taiwan（臺灣臺南市）\n\nHobbies\nMusic, art, reading and writing. Recently diving into Neovim. Check out my drawings and sound tracks!\n","plink":"https://jinchuangtw.github.io/About/"},{"title":"Links","date":"2022-08-13T08:30:28.000Z","date_formatted":{"ll":"Aug 13, 2022","L":"08/13/2022","MM-DD":"08-13"},"updated":"2022-08-13T08:34:59.906Z","content":"Hi! ☕️\nTracks\nhttps://soundcloud.com/void-j\nArtworks\nhttps://www.pixiv.net/users/15519192\nMy Playlists on Spotify\nhttps://open.spotify.com/user/31tp2ayaeont5cpjcg7zfichyqcm?si=82d16ce30b714494\n","plink":"https://jinchuangtw.github.io/Links/"}]