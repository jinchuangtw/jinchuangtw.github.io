[{"title":"Outlier Removal 演算法回顧 (1) - RANSAC","date":"2023-09-07T09:41:49.000Z","date_formatted":{"ll":"Sep 7, 2023","L":"09/07/2023","MM-DD":"09-07"},"updated":"2023-09-07T10:57:19.479Z","content":"本系列文將會介紹經典的三種 outlier removal 演算法，包括 RANSAC [1] 以及其衍生版本：MSAC (M-estimator) 與 MLESAC (Maximum Likelihood Estimate Sample Consensus) [2]。\n首先介紹 outlier 的直觀意義與這些演算法試圖達到的目的。\n量測數據解讀：雜訊與離群值 Noise and Outlier\n某一天，老師要學生用電子秤和直尺測量一支鉛筆的重量、長度。學生 A、B、C 測得的數據如下表所示，學生 C 由於誤讀電子秤上的數字，因此數據明顯跟其他兩位差異很多。\n\n\n\n學生 A\n學生 B\n學生 C\n\n\n\n\n重量\n15.02\n14.73\n25.35\n\n\n長度\n12.33\n11.98\n12.03\n\n\n明明量的都是同一支鉛筆，這些數據彼此之所以有所不同，可以歸因於以下兩點：\n\n\n儀器本身雜訊 -&gt; noise\n\n無論多精準的儀器，都一定無法避免雜訊。針對已知型態的雜訊，通常可以透過濾波器等方式消除。\n\n\n\n測量過程發生異常 -&gt; outlier\n\n\n本範例中提出的「誤讀」，就可以算是一種異常狀況。\n\n\n或者儀器本身故障，也可能導致測量出極端的數據。\n\n\n這類極端的數據稱為 outlier，較不易消除，且會對後續資料分析造成不利影響。\n\n\n\n\n當然，在真實情況下，沒有人知道這支鉛筆的真正重量與長度（ground truth value）是多少。因此，在進行資料判讀之前，我們有必要試圖排除這些 noise  與 outlier，才能使得量測數據盡可能地逼近真實數據。本文要介紹的三種演算法，其目的便是盡可能地剔除數據中的 outlier。\n範例說明\n接下來，我們將使用簡單的 line fitting 問題作為範例，介紹並比較各個經典演算法如何剔除 outlier，並得出好的估測結果。\n下圖呈現了一組帶有 noise 和 outlier 的數據，而其 ground truth 可以用一個斜直線式表示：\n\ny=f(x)=a_{true}x+b_{true} \\text{, where} \\left\\{\n\\begin{matrix}\na_{true}&amp;=2 \\\\\nb_{true}&amp;=10\n\\end{matrix}\n\\right.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n \n\n \n \n \n \n\n\n \n \n\n \n\n \n \n \n \n\n\n\n \n \n \n \n \n \n\n\n \n\n\n\n \n\n \n \n \n \n\n\n\n \n\n \n \n \n \n\n\n\n\n\n \n \n\n\n \n\n \n \n\n\n\n\n\n\n\n\n我們的目標是根據這些點估計出 \na_{est}\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n 與 \nb_{est}\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n 這兩個模型參數，使得它們盡可能接近 \na_{true}\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n 與 \nb_{true}\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n。\nRANSAC 概念與流程\nRANSAC 的核心精神可以用「亂槍打鳥、騎驢找馬」來形容。所謂「亂槍打鳥」，指的是隨機選取資料點來建立假說模型（hypothesis model，亦即，我們想要估計的模型參數），而「騎驢找馬」，則是對這些假說模型進行評分，並保留最高分的那一個。可以想見，一旦亂槍打鳥的次數夠多，那我們就很有機會找到一個逼近真實模型的估計結果。\n以這個 line fitting 問題來說，RANSAC 的步驟如下：\n\n\n根據資料中的任意兩點（也可以選更多點，並搭配 Least square）建立出一條直線 \ny\n\n\n\n\n \n\n\n\n\n找出這條直線的模型參數 \na_{est},\\,b_{est}\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n\n \n\n \n \n \n\n\n\n\n\n\n計算每一顆資料點和這條直線的距離，距離大於 \nc\n\n\n\n\n \n\n 者即判定為 outlier\n\n\n依據 outlier 個數，評估這次的猜測是好是壞，越多就代表模型越差\n\n\n若是至今最好的猜測，那就保留，若不是的話就直接丟棄。\n\n\n這些步驟將會一直循環到達到疊代終止條件為止。\n詳細而言，在 \nN\n\n\n\n\n \n\n 次的疊代中，你可能會獲得 \nN\n\n\n\n\n \n\n 個長得像這樣的東西：\n\n其中最佳的模型參數就會是最終 RANSAC 吐出的結果。到此為止，我們成功計算出了一組模型參數 \n(a_{est},\\,b_{est})=(2.06,\\,9.89)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n \n \n\n\n \n\n \n\n \n \n \n\n\n \n \n \n\n \n \n \n \n\n \n\n \n \n \n \n\n \n\n，RMSE 約為 \n0.0886\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n。\n再以數學來說，RANSAC 的目標即是在給定的有限次數內找到可以最小化 loss function 的那個最佳模型 \n\\hat{M}\n\n\n\n\n\n \n \n\n，如下式所示，式中符號定義可參考下方 pseudo code。\n\n\\hat{M}= \\arg\\min_{M}\\sum_{data \\in \\mathcal{D}}\\biggl\\{\\text{Loss} \\Bigl(\\text{Err}(data|M)\\Bigr) \\biggr\\}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n\n \n \n \n\n\n \n \n \n \n\n\n \n\n \n \n \n \n \n \n\n\n \n\n \n \n \n \n\n \n\n \n \n \n\n \n \n \n \n \n \n \n \n \n \n\n\nwhere\n\n\\text{Loss}_{RANSAC}=\\sum_{i=1}^nL,\\,L=\\left\\{\n    \\begin{matrix}\n        0 &amp; |e_i| &lt; c\\\\\n        1 &amp; \\text{otherwise}\n    \\end{matrix}\n    \\right.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n \n \n \n \n \n\n \n\n \n\n \n \n \n\n \n\n \n \n \n \n\n \n\n\n \n \n\n\n\n \n\n \n \n\n \n \n \n\n\n \n \n \n \n \n \n \n \n \n\n\n\n\n\n\n至於疊代次數上限的建議值，則可以據此計算：\n\nN=\\frac{\\log\\alpha}{\\log(1-\\gamma^m)}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n\n\n\n \n \n \n \n\n\n \n \n \n \n \n \n\n \n \n\n \n\n\n\n\n\n其中 \n\\alpha\n\n\n\n\n \n\n 代表估計失敗的機率，一般會直接設為 \n0.001\n\n\n\n\n\n\n \n \n \n \n \n\n。根據此式，疊代次數上限很大程度上依賴於 \nm\n\n\n\n\n \n\n 的選擇，因此如果計算出的 \nN\n\n\n\n\n \n\n 太小導致無法獲得可接受的結果，也可以考慮手動調整 \nN\n\n\n\n\n \n\n。\nPseudo Code\n\n\nInput:\n\n\n\n\\mathcal{D}_{n\\times d}\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n: Data (dimension \n=d\n\n\n\n\n\n \n \n\n)\n\n\n\nc\n\n\n\n\n \n\n: Threshold of error for dividing inliers and outliers\n\n\n\nm\n\n\n\n\n \n\n: Number of data required to generate a hypothesis\n\n\n\n\\gamma\n\n\n\n\n \n\n: Inlier ratio\n\n\n\n\nOutput:\n\n\n\\hat{M}\n\n\n\n\n\n \n \n\n: Best estimated model\n\n\n\n\n\nMaximum iteration time \nN=\\frac{\\log\\alpha}{\\log(1-\\gamma^m)}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n\n\n\n \n \n \n \n\n\n \n \n \n \n \n \n\n \n \n\n \n\n\n\n\n (or selected manually)\n\n\nWhile (iteration time &lt; \nN\n\n\n\n\n \n\n)\n\n\nRandomly sample \nm\n\n\n\n\n \n\n data to generate a hypothesis \nM\n\n\n\n\n \n\n\n\n\nCalculate error \ne_i\n\n\n\n\n\n \n \n\n for each data point under \nM\n\n\n\n\n \n\n\n\n\nCalculate Loss which is the number of data points fulfilling \n|e_i|&gt;c\n\n\n\n\n\n\n\n\n \n\n \n \n\n \n \n \n\n\n\n\nIf (Loss is the minimum until now)\n\nUpdate \n\\hat{M} \\leftarrow M\n\n\n\n\n\n\n \n \n \n \n\n\n\n\n\nEndIf\n\n\n\n\nEndWhile\n\n\nRANSAC 的自定義參數\n經過以上範例與統整，可以看出用 RANSAC 處理數據時，總共需要用到三個自定義參數，包括用來區分 inlier 與 outlier 的閥值 \nc\n\n\n\n\n \n\n、用來建立假說模型的資料點數 \nm\n\n\n\n\n \n\n，以及疊代總次數 \nN\n\n\n\n\n \n\n。其中，對演算法準確性影響最大的即是 \nc\n\n\n\n\n \n\n。\n\nc\n\n\n\n\n \n\n 的選擇\n\n左圖 \nc=2\n\n\n\n\n\n\n \n \n \n\n，右圖 \nc=10\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n。當 \nc\n\n\n\n\n \n\n 的選擇與這筆資料分布的 noise 大小差距越遠，RANSAC 越難以精準判斷 outlier 與 inlier。以右邊的情況為例，由於 \nc\n\n\n\n\n \n\n 選取過大，RANSAC 認為這個模型中已經包含了很多 inlier，故將其誤判為一個好的模型。\n\nm\n\n\n\n\n \n\n 與 \nN\n\n\n\n\n \n\n 的選擇\n這兩個參數對於準確性的影響相對較低，然而若想在較少的疊代次數以內找到一個好模型，則可以考慮提升 \nm\n\n\n\n\n \n\n 的大小，並搭配 Least sqare method，透過 \nm\n\n\n\n\n \n\n 筆資料建立出單一個假說模型，但這也可能導致整體計算時間拉長，需要以實作結果決定較好的方案。\nReferences\n[1] M. A. Fischler and R. C. Bolles, “Random sample consensus: a paradigm for model fitting with applications to image analysis and automated cartography,” Communications of the ACM, vol. 24, no. 6, pp. 381–395, 1981.\n[2] P. H. Torr and A. Zisserman, “MLESAC: A new robust estimator with application to estimating image geometry,” Computer vision and image understanding, vol. 78, no. 1, pp. 138–156, 2000.\n","thumbnail":"2023/09/07/23-09-07-Outlier-Removal-1/models.png","plink":"https://jinchuangtw.github.io/2023/09/07/23-09-07-Outlier-Removal-1/"},{"title":"ORB-SLAM2 Test Log (With KITTI Dataset on ROS)","date":"2022-10-28T06:43:35.000Z","date_formatted":{"ll":"Oct 28, 2022","L":"10/28/2022","MM-DD":"10-28"},"updated":"2022-10-28T06:57:36.675Z","content":"This note shows a brief test process on the open-source code of ORB-SLAM2.\n\nEnvironment Setup ::\n\nubuntu 18.04 LTS\nROS Melodic\nOpenCv 3.2.0 with contrib module\nPangolin @ 1ec721d (Github)\n\nDownload and Build\n1234567cd $(your_catkin_workspace)/srcgit clone https://github.com/raulmur/ORB_SLAM2.gitcd ORB_SLAM2chmod +x build.shchmod +x build_ros.sh./build.sh./build_ros.sh\nBuilding Problems Encountered\n1. Error: ‘usleep’ was not declared in this scope\nAdd #include&lt;unistd.h&gt; into all the error files.\n2. For build_ros.sh, DSO missing from command line … Makefile:129: recipe for target ‘all’ failed\nAdd this into /Examples/ROS/ORB_SLAM2/CMakeLists/txt\n12345set(LIBS# ...-lboost_system # add this line!# ...)\n\nThen the building process should be finished successfully.\n\nRun Examples with KITTI\nDownload KITTI dataset here\n\nIn this test, we used sequence 00 in the odometry data set (grayscale, 22 GB), for a stereo example.\n\n12cd $(your_catkin_workspace)/src/ORB_SLAM2./Examples/Stereo/stereo_kitti Vocabulary/ORBvoc.txt Examples/Stereo/KITTI00-02.yaml $(PATH_TO_YOUR_DATASET_FOLDER)/dataset/sequences/00\nProblems Encountered - SLAM.shutdown() Not Working\nBy doing the previous part, we can find that the CameraTrajectory.txt file is not generated after the whole sequence is over.\nAfter checking for stereo_kitti.cc, we can find that SLAM.shutdown() is not working properly.\nHence, we should add 2 lines into System.cc like\n123456789if(mpViewer) &#123;    mpViewer-&gt;RequestFinish();    while(!mpViewer-&gt;isFinished())        usleep(5000);        // add these 2 lines    delete mpViewer;    mpViewer = static_cast&lt;Viewer*&gt;(NULL);&#125;\n\nMake again in the build folder. Problem solved!\n\n","plink":"https://jinchuangtw.github.io/2022/10/28/22-10-28-ORBSLAM2-Test-log/"},{"title":"使用 CMake 建置 OpenCV 專案","date":"2022-09-02T13:52:41.000Z","date_formatted":{"ll":"Sep 2, 2022","L":"09/02/2022","MM-DD":"09-02"},"updated":"2022-09-02T15:47:38.424Z","content":"簡單記錄一下 CMake 的基本使用方式與專案結構。\n\nCMake 是什麼\nCMake 是一個可以管理並建置程式專案的工具，直觀一點地說，它可以幫你引入程式需要的第三方函式庫，並連同專案內的 header files、source files 一起編譯出最終的執行檔。同時，CMake 也是 OpenCV 官方文件中優先建議的編譯工具。用來設置 CMake 各項參數的檔案，就叫做 CMakeLists.txt，使用者必須根據自己的需求，把各個檔案的路徑寫在這裡面，告訴 CMake 程式檔案之間的關聯。\n專案結構\n參考視覺SLAM十四講 Chapter 13 的內容，可以看到專案根目錄首先會有一個最主要的 CMakeLists.txt，而在 src、app、test 這三個資料夾底下也各有一個。另外，一些第三方函式庫的詳細引用方法，則定義在 cmake_modules 的 .cmake 檔案中。完整的專案結構如下所示：\n123456789101112131415161718project_root          |-- app          |    |-- CMakeLists.txt          |    |-- run_kitti_stereo.cpp          |-- config               |-- cmake_modules          |             |-- FindCSparse.cmake          |             |-- FindG2O.cmake          |             |-- FindGlog.cmake          |-- include/myslam          |             |-- (... user header files ...)          |-- src          |    |-- CMakeLists.txt          |    |-- (... user source files ...)          |-- test          |    |-- CMakeLists.txt          |    |-- test_triangulation.cpp          |-- CMakeLists.txt\n由這個結構可以看出，使用者應將自己寫的 header files 放在 include 目錄中，並使用自定義的函式庫名稱作為子資料夾。而所有的 source files 則可以放在 src 目錄下。\n再來，test 和 app 目錄下則用來存放測試用的程式，以及專案的主程式。\nCMake 設置常用語法\nCMake 專案設置\n首先在根目錄中、最主要的那個 CMakeLists.txt 裡面，使用者必須先設定好版本與專案資訊。如果有將第三方函式庫的詳細引入方式寫成 .cmake 檔的話，可以註明那些檔案的位置。\n12345678cmake_minimum_required(VERSION 2.8)project(myslam)set(CMAKE_BUILD_TYPE Release) # Release / Debug，debug的話，編譯出的執行檔會跑得比較慢list(APPEND CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake_modules) # .cmake 的路徑set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin) # 執行檔輸出路徑set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib) # 使用者函式庫編譯路徑\n引入 OpenCV 等等第三方函式庫\n再來，使用者可以透過 find_package 讓 CMake 自己尋找第三方套件的檔案路徑，並且用 include_directories 告訴 CMake 要把這些東西加到專案的 include 路徑裡面，這樣我們的程式就可以使用第三方的 functions。\n1234# OpenCVfind_package(OpenCV 3.1 REQUIRED) # 也可以像這樣指定套件版本include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)set(THIRD_PARTY_LIBS $&#123;OpenCV_LIBS&#125;) # 把多個第三方函示庫的路徑整理在一起，統稱 THIRD_PARTY_LIBS\n引入使用者自己的函式庫\n剛剛已經把專案底下使用者自己寫的 libraries 都放在 include 目錄下了，所以這邊只需要直接用 include_directories 把他們加進去就好。\n1include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)\n定義來源檔案路徑\n在上一小節有提到來源檔案根據性質（是 libraries 還是主程式？）可以放在對應的資料夾中。這邊就運用 add_subdirectory 告訴 CMake 這些來源檔案的路徑。\n123add_subdirectory(src)add_subdirectory(test)add_subdirectory(app)\n編譯函式庫\n使用者自己函式庫的來源檔案可以透過 add_library 進行連結。如果這個函式庫也需要用到第三方函式庫的東西，可以再用 target_link_libraries 把它們連起來。\n123456789101112131415add_library(myslam SHARED # 使用者函式庫名稱與類型        frame.cpp        mappoint.cpp        map.cpp        camera.cpp        config.cpp        feature.cpp        frontend.cpp        backend.cpp        viewer.cpp        visual_odometry.cpp        dataset.cpp)target_link_libraries(myslam        $&#123;THIRD_PARTY_LIBS&#125;)\n編譯主程式\nadd_executable 可以告訴 CMake 要根據誰產生執行檔，以及執行檔要叫什麼名字。主程式裡面用到的所有函式庫則可以一次用 target_link_libraries 進行連結。\n12add_executable(run_kitti_stereo run_kitti_stereo.cpp) # 執行檔名稱 與 主程式檔名target_link_libraries(run_kitti_stereo myslam $&#123;THIRD_PARTY_LIBS&#125;) # 這個執行檔會用到的函式庫們\n結語\n假設專案非常簡單，使用者其實只需要一個 CMakeLists.txt 就可以搞定所有設置，但是，實務上的大型專案往往包括許多使用者自己寫的函式庫與多個程式，如同這次的範例，我們可以利用模組化的方式來進行 CMake 連結，也更好進行檔案管理。至於這次沒有寫到的測試檔案設置方式，就等日後有需要用到時再進行研究補充。\nThumbnail photo from Unsplash\n","thumbnail":"2022/09/02/22-09-02-cmake-tutorial/thumbnail.png","plink":"https://jinchuangtw.github.io/2022/09/02/22-09-02-cmake-tutorial/"},{"title":"Leetcode - 9. Palindrome Number","date":"2022-08-19T10:50:34.000Z","date_formatted":{"ll":"Aug 19, 2022","L":"08/19/2022","MM-DD":"08-19"},"updated":"2022-08-19T12:37:12.662Z","content":"009. Palindrome Number\nProblem\nhttps://leetcode.com/problems/palindrome-number/\nIntuition\nIn this problem, we have to reverse the input integer to see whether the reversed number is the same as the original input. So the first solution that came to my mind was to reverse it and store the result in a new variable. By this way, we could directly return reversed number == input number.\nSolution Planning\n\nSince the input may be negative, we could return false once x &lt; 0.\nSince the input constrain is \n-2^{31} \\leq x \\leq 2^{31}-1\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n \n\n\n \n \n \n\n \n\n \n \n\n\n \n \n\n, if we reverse an integer with 10 digits, it may exceed the limit of int. This could be solved by using long long.\n\nCode\n12345678910111213bool isPalindrome(int x) &#123;    if (x &lt; 0) &#123;        return false;    &#125; else &#123;        long long reversedNum = 0;        int lost = x;        while (lost != 0) &#123;            reversedNum = reversedNum * 10 + lost % 10;            lost = lost / 10;        &#125;        return reversedNum == x;    &#125;&#125;\n","plink":"https://jinchuangtw.github.io/2022/08/19/22-08-19-leetcode-009/"},{"title":"Neovim 高效開發環境：配置心得與分享","date":"2022-08-05T06:59:34.000Z","date_formatted":{"ll":"Aug 5, 2022","L":"08/05/2022","MM-DD":"08-05"},"updated":"2022-09-03T11:48:17.143Z","content":"10dd 一次刪除 10 行、yG 複製至檔案末端 … 是時候挑戰這個神秘古老的編輯器了。\n\n\n點擊畫面右下角選單可以開啟目錄！\n\n前言：為何不使用現成的 IDE\n在這個人人學程式的時代，集成式開發環境（Integrated Development Environment, IDE）往往是入門者寫程式的首選，其直覺化的圖形介面、便捷的程式庫引入方式，可以讓使用者免於繁複的設定，只需專注學習程式的概念以及語法 —— 例如我在大學修 C、C++ 時常用的 Visual Studio，抑或是 Python 專用的 PyCharm 等。\n然而，此類 IDE 往往有著以下顯著的缺點：\n\n軟體檔案肥大，佔據電腦大量儲存空間\n\n相對輕量化的開源 IDE 如：Dev-C++，是我八年前（欸？）最喜歡的編輯器，可惜作者已不再更新、維護\n\n\n啟動速度慢，而且當你裝了越多插件，就又更慢\n介面充滿花花綠綠的按鈕與各種複雜的 panels，壓縮程式碼的編輯空間，換言之就是很醜（主觀發言）\n\n另外，不同於龐大精密的 IDE，近年備受開發者青睞的 Visual Studio Code 與 Atom 這類現代化文字編輯器，則可以透過自行安裝的插件來滿足各式使用需求，不論是不同程式語言的開發，或是 tex、markdown 等等文件編輯，都可以在插件市集中找到支援。\n不過，在文字編輯器的領域，依然存在著一個神秘古老的選擇，從未離開人們的視野… 對，那就是 Vim。兼具超輕量化、跨平台通用性（Linux, macOS, WSL）、100% 可自定義的功能以及讓你可以就此丟掉滑鼠的快捷鍵組合，使得 Vim 成為一套讓使用者「越用越順手」的開發環境。若再搭配 tmux 使用，更可以使整個終端機工作的效率達到最大值。\n\n    \n\n\n推我入坑的最大契機：Neovim + tmux = 超級順暢的 workflow！(How to build a smoothly animated ToDo app with React Native, Expo, Reanimated, NativeBase, and Moti – devaslife@YouTube)\n\n本文使用的 Neovim 則是源自 Vim 的分支版本。不同於 Vim 只由一位主要開發者進行所有 pull requests 的管理，Neovim 的開發社群相對龐大，因此在新功能的增添上更為活絡。我在這篇文章中的配置方式參考了這篇教學，作者對 Neovim 的配置概念與步驟做了非常詳細的說明。\n一、Neovim 基礎安裝與環境配置\nNeovim 的安裝非常簡單，可以直接透過 apt 或 brew 之類的套件管理器完成。例如：\nmacOS\n1brew install neovim --HEAD\nLinux / WSL 的話是\n12sudo apt updatesudo apt install neovim\n另外，我們還會需要一個可以正常顯示 nerd 字符的環境。不同於各平台終端機內建的字型，nerd-font 的好處是支援各種圖形符號，可以讓我們的 UI 更為美觀直覺。我在 WSL 用的終端機是 Tabby，macOS 則是 iTerm2，這些終端機都可以支援 nerd-font。\nNerd-font 有非常多種字型可以選擇，我自己是用這些：\n\nMesloLGS NF Regular.ttf\nMesloLGS NF Bold.ttf\nMesloLGS NF Italic.ttf\nMesloLGS NF BoldItalic.ttf\n\n二、配置文件架構\nNeovim 跟 Vim 比較不一樣，使用者必須在自己的家目錄底下建立 .config/nvim 路徑，並把所有相關配置文件都放到裡面。每次打開 Neovim，它都會自動執行 init.lua 這個入口文件，把裡面所有設定都跑一遍。\n這些檔案的架構大概會是這個樣子：\n12345678910111213~/.config/nvim    |    |--- init.lua # 入口文件    |--- lua    |     |--- basic.lua # 顯示與 Neovim 基本設定    |     |--- keybingings.lua # 快捷鍵自定義    |     |--- colorscheme.lua # 外觀主題    |     |--- plugins.lua # 管理所有插件的安裝    |     |--- plugin-config    |     |          |--- # ... 插件各自的配置    |     |     |     |--- lsp    |     |     |--- # ... lsp server 各自的配置\n將各個插件的配置以模組概念分開來的好處是，當你某一天想要關閉某個插件時，只需要把入口文件中引入那個插件的一行 code 註解掉就可以了。\n三、插件 &amp; 我的配置分享\n在插件管理上，我用的是 packer.nvim，先把這個管理器安裝好之後，只要把所有想安裝的插件列在 plugins.lua，然後執行 :PackerSync 就可以了。另外，如果是要把 Neovim 拿來寫 code，不外乎還會需要以下這些功能：\n\n語法高亮\n自動補全\nCode 自動排版\n模糊搜索\n檔案管理介面\n\n詳細相關的插件，可以參考我的 Neovim 配置文件，由於我主要是打算拿來寫 c、cpp、python、tex 還有 markdown，所以如果還需要寫其他語言，就必須安裝相對應的 LSP server，才能實現自動補全功能。各語言可用的 server 可以參考 nvim-lspconfig 的說明文件。Code 自動排版的部分則可以參考 null-ls 的 built-in sources，注意在配置好之後，也要安裝各語言自動排版的套件，null-ls 才可以去 call 它。\n例如我看到 null-ls 可以用 clang-format 這個 command 去排版 c 跟 cpp，\n\n那我就知道我必須另外安裝 clang-format，以此類推。\n\n透過這次下定決心把 Neovim 配起來，終於可以在全 terminal 環境下作業了！完全不用伸手碰滑鼠就是爽(=´∀｀)人(´∀｀=)\n\n用 Neovim 搭配 tmux 的多開方法，左邊編輯，右邊開 server，即時查看渲染結果。\nThumbnail photo from Unsplash\n","thumbnail":"2022/08/05/22-08-05-neovim-tutorial/coding.jpg","plink":"https://jinchuangtw.github.io/2022/08/05/22-08-05-neovim-tutorial/"},{"title":"About","date":"2022-08-13T07:48:50.000Z","date_formatted":{"ll":"Aug 13, 2022","L":"08/13/2022","MM-DD":"08-13"},"updated":"2023-09-01T04:21:20.499Z","content":"\n“My formula for greatness in a human being is amor fati: that one wants nothing to be different, not forward, not backward, not in all eternity. Not merely bear what is necessary, still less conceal it—all idealism is mendacity in the face of what is necessary—but love it.” – Friedrich Nietzsche\n\nResearch\n\nStereo V-SLAM\n\nMaster Thesis\n\nStereo Vision Assisted Landing System for Fixed-Wing UAVs with Risk-Awareness\n\n\nIEEE Publications\n\nEvaluation of ORB-SLAM based Stereo Vision for the Aircraft Landing Status Detection on 2022 IECON\n\n\n\n\nEmbedded Operating System\n\nBuilt An Embedded System for Field Workers Safety Detection based on FreeRTOS\n\n\n\nProgramming\n\nC++\nC\nPython\nMatlab\n\nBio\n\nNow\nStudying at NCKU dept. of Aeronautics and Astronautics （國立成功大學航空太空工程研究所）\n2021\nGraduated from NCKU dept. of Aeronautics and Astronautics（國立成功大學航空太空工程學系）\n2017\nGraduated from National Tainan Girls’ Senior High School（國立臺南女子高級中學）\n1999\nBorn in Tainan, Taiwan（臺灣臺南市）\n\nHobbies\nMusic, art, reading and writing. Recently diving into Neovim. Check out my drawings and sound tracks!\n","plink":"https://jinchuangtw.github.io/About/"},{"title":"Links","date":"2022-08-13T08:30:28.000Z","date_formatted":{"ll":"Aug 13, 2022","L":"08/13/2022","MM-DD":"08-13"},"updated":"2022-08-13T08:34:59.906Z","content":"Hi! ☕️\nTracks\nhttps://soundcloud.com/void-j\nArtworks\nhttps://www.pixiv.net/users/15519192\nMy Playlists on Spotify\nhttps://open.spotify.com/user/31tp2ayaeont5cpjcg7zfichyqcm?si=82d16ce30b714494\n","plink":"https://jinchuangtw.github.io/Links/"}]